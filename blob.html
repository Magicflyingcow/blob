<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Blob Life Simulation</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050709;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      display: flex;
      gap: 16px;
      max-width: 1200px;
      width: 100%;
    }

    .panel {
      background: radial-gradient(circle at top left, #1c1e2b, #090b12 60%);
      border-radius: 16px;
      padding: 16px 18px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }

    #canvasPanel {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #sim {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.09);
      background: radial-gradient(circle at 30% 0%, #151826, #05070f 70%);
      display: block;
      width: 100%;
      height: auto;
    }

    #nnPanel {
      width: 100%;
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
    }

    #nnTitle {
      font-size: 0.82rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #d4defc;
      opacity: 0.9;
      margin-bottom: 6px;
    }

    #nnCanvas {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: radial-gradient(circle at top, #111628, #05070f 70%);
      display: block;
      width: 100%;
      height: auto;
    }

    #controlPanel {
      width: 270px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    h1 {
      font-size: 1.1rem;
      margin: 0 0 8px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #d4defc;
    }

    .controls {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }

    button {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: none;
      font-weight: 600;
      font-size: 0.85rem;
      cursor: pointer;
      background: linear-gradient(135deg, #3c7df6, #a053ff);
      color: white;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
      transition: transform 0.08s ease, box-shadow 0.08s ease, filter 0.1s ease;
    }

    button.secondary {
      background: rgba(255, 255, 255, 0.06);
      box-shadow: none;
    }

    button:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow: 0 7px 22px rgba(0, 0, 0, 0.6);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      filter: brightness(0.97);
    }

    .slider-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.8rem;
      margin-top: 6px;
    }

    .slider-label {
      display: flex;
      justify-content: space-between;
      color: rgba(241, 244, 255, 0.9);
    }

    input[type="range"] {
      width: 100%;
    }

    #stats {
      font-size: 0.78rem;
      line-height: 1.4;
      padding: 10px;
      border-radius: 10px;
      background: rgba(8, 11, 22, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.05);
      margin-top: 4px;
    }

    #legend {
      font-size: 0.78rem;
      line-height: 1.4;
      padding: 10px;
      border-radius: 10px;
      background: rgba(10, 14, 28, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.04);
    }

    #legend strong {
      font-weight: 600;
      color: #fdfdff;
    }

    .pill {
      display: inline-block;
      padding: 2px 7px;
      border-radius: 999px;
      font-size: 0.7rem;
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.85);
      margin-right: 4px;
      margin-bottom: 2px;
    }

    .footer-note {
      font-size: 0.7rem;
      opacity: 0.6;
      margin-top: 4px;
    }

    @media (max-width: 900px) {
      body {
        align-items: stretch;
      }
      .container {
        flex-direction: column;
      }
      #controlPanel {
        width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <div id="canvasPanel" class="panel">
    <h1>Blob Life Simulation</h1>
    <canvas id="sim"></canvas>

    <div id="nnPanel">
      <div id="nnTitle">Highest generation neural network</div>
      <canvas id="nnCanvas"></canvas>
    </div>
  </div>

  <div id="controlPanel" class="panel">
    <div>
      <div class="controls">
        <button id="toggleBtn">Pause</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>

      <div class="slider-group">
        <div class="slider-label">
          <span>Simulation speed</span>
          <span id="speedValue">1.0x</span>
        </div>
        <input id="speedSlider" type="range" min="0.1" max="3" step="0.1" value="1" />
      </div>

      <div class="slider-group">
        <div class="slider-label">
          <span>Food spawn rate</span>
          <span id="foodRateValue">3.0/s</span>
        </div>
        <input id="foodRateSlider" type="range" min="0" max="10" step="0.1" value="3" />
      </div>
    </div>

    <div id="stats"></div>

    <div id="legend">
      <div class="pill">Color ↔ lineage</div>
      <p><strong>Color:</strong> Encodes family trees: founders set a base hue, with subtle shifts per descendant generation.</p>
      <p><strong>Inputs:</strong> 5 food rays + 5 blob rays across a 120° FOV (left → right), plus energy level and a bias term.</p>
      <p><strong>Hidden layers:</strong> 16 neurons → 16 neurons.</p>
      <p><strong>Outputs:</strong> Turn and thrust control the blob’s heading and speed.</p>
      <p><strong>World edges:</strong> Blobs bounce off the borders of the world; no wrapping.</p>
      <p><strong>Food:</strong> Environment slowly refills food up to a cap, at the adjustable spawn rate. Distantly related blobs may also opportunistically consume one another.</p>
      <p class="footer-note">
        Watch color clusters and the visual NN as lineages explore deeper 2-layer brains.
      </p>
    </div>
  </div>
</div>

<script>
  // --- CONFIGURATION --------------------------------------------------------
  const CONFIG = {
    worldWidth: 2500,
    worldHeight: 1500,
    initialBlobs: 24,
    maxBlobs: 900,

    foodCount: 2000,          // max / target food in the world
    foodRadius: 3,
    foodEnergy: 28,
    defaultFoodSpawnRate: 3, // foods per second (when slider is at default)

    baseSpeed: 42,           // pixels per second baseline
    maxTurnRate: Math.PI,    // radians per second
    energyLossPerSecond: 4,  // passive drain
    moveEnergyFactor: 0.07, // extra drain based on movement

    initialEnergy: 80,
    reproductionEnergy: 200,
    minEnergyToLive: 0,

    // Predation
    predationChance: 0.22,
    predationEnergyTransfer: 0.8,
    predationReachFactor: 1.6,
    relatednessThreshold: 0.35,

    // Field of view (degrees)
    fovDegrees: 120,         // blobs can see 120° in front

    // Trait ranges
    speedMin: 0.65,
    speedMax: 1.45,
    sensorMin: 70,
    sensorMax: 500,
    sizeMin: 0.8,
    sizeMax: 1.5,

    // Mutation strengths
    traitMutation: 0.06,
    weightMutation: 0.04,

    // Neural network sizes
    // 5 food rays + 5 blob rays + energy + bias = 12 inputs
    nnInputSize: 12,
    nnHidden1Size: 16,
    nnHidden2Size: 16,
    nnOutputSize: 2
  };

  // --- UTILS ---------------------------------------------------------------
  function randRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
  }

  function distanceSq(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return dx * dx + dy * dy;
  }

  // --- NEURAL NETWORK ------------------------------------------------------
  class Brain {
    constructor(
      inputSize,
      hidden1Size,
      hidden2Size,
      outputSize,
      weightsIH,
      weightsHH,
      weightsHO,
      biasH1,
      biasH2,
      biasO
    ) {
      this.inputSize = inputSize;
      this.hidden1Size = hidden1Size;
      this.hidden2Size = hidden2Size;
      this.outputSize = outputSize;

      this.weightsIH = weightsIH || Brain.randomMatrix(hidden1Size, inputSize);
      this.weightsHH = weightsHH || Brain.randomMatrix(hidden2Size, hidden1Size);
      this.weightsHO = weightsHO || Brain.randomMatrix(outputSize, hidden2Size);
      this.biasH1 = biasH1 || Brain.randomArray(hidden1Size);
      this.biasH2 = biasH2 || Brain.randomArray(hidden2Size);
      this.biasO = biasO || Brain.randomArray(outputSize);
    }

    static randomArray(n) {
      const arr = new Array(n);
      for (let i = 0; i < n; i++) {
        arr[i] = (Math.random() * 2 - 1) * 0.8;
      }
      return arr;
    }

    static randomMatrix(rows, cols) {
      const m = new Array(rows);
      for (let r = 0; r < rows; r++) {
        m[r] = new Array(cols);
        for (let c = 0; c < cols; c++) {
          m[r][c] = (Math.random() * 2 - 1);
        }
      }
      return m;
    }

    static cloneAndMutate(parent, rate) {
      function cloneArray(arr) {
        return arr.slice();
      }
      function cloneMatrix(mat) {
        return mat.map(row => row.slice());
      }
      function mutateValue(v) {
        return v + (Math.random() * 2 - 1) * rate;
      }

      const weightsIH = cloneMatrix(parent.weightsIH).map(row => row.map(mutateValue));
      const weightsHH = cloneMatrix(parent.weightsHH).map(row => row.map(mutateValue));
      const weightsHO = cloneMatrix(parent.weightsHO).map(row => row.map(mutateValue));
      const biasH1 = cloneArray(parent.biasH1).map(mutateValue);
      const biasH2 = cloneArray(parent.biasH2).map(mutateValue);
      const biasO = cloneArray(parent.biasO).map(mutateValue);

      return new Brain(
        parent.inputSize,
        parent.hidden1Size,
        parent.hidden2Size,
        parent.outputSize,
        weightsIH,
        weightsHH,
        weightsHO,
        biasH1,
        biasH2,
        biasO
      );
    }

    forward(inputs) {
      // First hidden layer
      const hidden1 = new Array(this.hidden1Size);
      for (let i = 0; i < this.hidden1Size; i++) {
        let sum = this.biasH1[i];
        for (let j = 0; j < this.inputSize; j++) {
          sum += this.weightsIH[i][j] * inputs[j];
        }
        hidden1[i] = Math.tanh(sum);
      }

      // Second hidden layer
      const hidden2 = new Array(this.hidden2Size);
      for (let i = 0; i < this.hidden2Size; i++) {
        let sum = this.biasH2[i];
        for (let j = 0; j < this.hidden1Size; j++) {
          sum += this.weightsHH[i][j] * hidden1[j];
        }
        hidden2[i] = Math.tanh(sum);
      }

      // Output layer
      const outputs = new Array(this.outputSize);
      for (let k = 0; k < this.outputSize; k++) {
        let sum = this.biasO[k];
        for (let i = 0; i < this.hidden2Size; i++) {
          sum += this.weightsHO[k][i] * hidden2[i];
        }
        outputs[k] = Math.tanh(sum); // [-1,1]
      }
      return outputs;
    }
  }

  // --- BLOB ---------------------------------------------------------------

  let NEXT_BLOB_ID = 1;

  class Blob {
    constructor(x, y, traits, brain, generation = 1, parent = null, lineageRootId = null, lineagePath = null) {
      this.id = NEXT_BLOB_ID++;
      this.x = x;
      this.y = y;
      this.heading = Math.random() * Math.PI * 2;
      this.energy = CONFIG.initialEnergy;
      this.traits = traits;
      this.brain = brain;
      this.generation = generation;

      this.lineageRootId = lineageRootId ?? (parent ? parent.lineageRootId : this.id);
      this.lineagePath = lineagePath ? [...lineagePath, this.id] : [this.id];
    }

    static randomTraits() {
      return {
        speed: randRange(CONFIG.speedMin, CONFIG.speedMax),
        sensorRange: randRange(CONFIG.sensorMin, CONFIG.sensorMax),
        size: randRange(CONFIG.sizeMin, CONFIG.sizeMax)
      };
    }

    static mutateTraits(parentTraits) {
      function mutateTrait(v, rangeMin, rangeMax) {
        const span = rangeMax - rangeMin;
        const delta = (Math.random() * 2 - 1) * CONFIG.traitMutation * span;
        return clamp(v + delta, rangeMin, rangeMax);
      }
      return {
        speed: mutateTrait(parentTraits.speed, CONFIG.speedMin, CONFIG.speedMax),
        sensorRange: mutateTrait(parentTraits.sensorRange, CONFIG.sensorMin, CONFIG.sensorMax),
        size: mutateTrait(parentTraits.size, CONFIG.sizeMin, CONFIG.sizeMax)
      };
    }

    get radius() {
      return 4.0 * this.traits.size;
    }

    // Color encodes lineage rather than brain weights
    getColor() {
      const rootHue = (this.lineageRootId * 47) % 360;
      const branchHue = (this.lineagePath[this.lineagePath.length - 1] * 29.7) % 36;
      const hue = (rootHue + branchHue) % 360;

      const saturation = 60 + Math.min(this.generation * 3, 25);
      const lightness = clamp(30 + this.generation * 2 + (this.lineagePath.length % 6) * 2, 30, 70);

      return `hsl(${hue.toFixed(0)}, ${saturation.toFixed(0)}%, ${lightness.toFixed(0)}%)`;
    }

    relatedness(other) {
      const len = Math.min(this.lineagePath.length, other.lineagePath.length);
      let common = 0;
      for (let i = 0; i < len; i++) {
        if (this.lineagePath[i] !== other.lineagePath[i]) break;
        common++;
      }
      const longest = Math.max(this.lineagePath.length, other.lineagePath.length);
      return longest === 0 ? 0 : common / longest;
    }

    attemptPredation(blobs, stats) {
      const attackRadius = this.radius * CONFIG.predationReachFactor;
      const attackRadiusSq = attackRadius * attackRadius;

      for (let i = 0; i < blobs.length; i++) {
        const other = blobs[i];
        if (other === this || other.dead) continue;

        const relatedness = this.relatedness(other);
        if (relatedness >= CONFIG.relatednessThreshold) continue;

        if (distanceSq(this, other) <= attackRadiusSq && Math.random() < CONFIG.predationChance) {
          other.dead = true;
          const transferred = other.energy * CONFIG.predationEnergyTransfer;
          this.energy += transferred;
          stats.predations++;
          stats.deaths++;
          break;
        }
      }
    }

    // 5-ray food and blob sensing across the FOV
    sense(foods, blobs) {
      const sensorRange = this.traits.sensorRange;
      const sensorRangeSq = sensorRange * sensorRange;

      const fovRad = (CONFIG.fovDegrees * Math.PI) / 180;
      const halfFov = fovRad / 2;

      const rayCount = 5;
      const foodRayDistSq = new Array(rayCount).fill(Infinity);
      const blobRayDistSq = new Array(rayCount).fill(Infinity);

      for (let i = 0; i < foods.length; i++) {
        const f = foods[i];
        const dx = f.x - this.x;
        const dy = f.y - this.y;
        const d2 = dx * dx + dy * dy;
        if (d2 > sensorRangeSq) continue;

        const angleToFood = Math.atan2(dy, dx);
        let relAngle = angleToFood - this.heading;

        // Wrap to [-PI, PI]
        while (relAngle > Math.PI) relAngle -= Math.PI * 2;
        while (relAngle < -Math.PI) relAngle += Math.PI * 2;

        if (Math.abs(relAngle) > halfFov) continue;

        const t = (relAngle + halfFov) / fovRad;      // 0..1
        let idx = Math.round(t * (rayCount - 1));     // 0..4
        idx = clamp(idx, 0, rayCount - 1);

        if (d2 < foodRayDistSq[idx]) {
          foodRayDistSq[idx] = d2;
        }
      }

      for (let i = 0; i < blobs.length; i++) {
        const other = blobs[i];
        if (other === this || other.dead) continue;

        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const d2 = dx * dx + dy * dy;
        if (d2 > sensorRangeSq) continue;

        const angleToBlob = Math.atan2(dy, dx);
        let relAngle = angleToBlob - this.heading;

        // Wrap to [-PI, PI]
        while (relAngle > Math.PI) relAngle -= Math.PI * 2;
        while (relAngle < -Math.PI) relAngle += Math.PI * 2;

        if (Math.abs(relAngle) > halfFov) continue;

        const t = (relAngle + halfFov) / fovRad;      // 0..1
        let idx = Math.round(t * (rayCount - 1));     // 0..4
        idx = clamp(idx, 0, rayCount - 1);

        if (d2 < blobRayDistSq[idx]) {
          blobRayDistSq[idx] = d2;
        }
      }

      // Convert ray distances to [0,1] signals
      function toSignals(rayDistSq) {
        const signals = new Array(rayCount).fill(0);
        for (let r = 0; r < rayCount; r++) {
          if (rayDistSq[r] < Infinity) {
            const dist = Math.sqrt(rayDistSq[r]);
            signals[r] = 1 - clamp(dist / sensorRange, 0, 1);
          } else {
            signals[r] = 0;
          }
        }
        return signals;
      }

      const foodSignals = toSignals(foodRayDistSq);
      const blobSignals = toSignals(blobRayDistSq);

      const energyNorm = clamp(this.energy / CONFIG.reproductionEnergy, 0, 1);
      const bias = 1;

      // 12 inputs: 5 food rays + 5 blob rays (L → R), energy, bias
      return [
        foodSignals[0],
        foodSignals[1],
        foodSignals[2],
        foodSignals[3],
        foodSignals[4],
        blobSignals[0],
        blobSignals[1],
        blobSignals[2],
        blobSignals[3],
        blobSignals[4],
        energyNorm,
        bias
      ];
    }

    update(dt, foods, blobs, stats) {
      const inputs = this.sense(foods, blobs);
      const [turnOutRaw, thrustOutRaw] = this.brain.forward(inputs);

      const turnOut = clamp(turnOutRaw, -1, 1);
      const thrustOut = clamp(thrustOutRaw, -1, 1);

      const turnRate = CONFIG.maxTurnRate * turnOut;
      this.heading += turnRate * dt;

      const thrust = (thrustOut + 1) * 0.5; // 0..1
      const speed = CONFIG.baseSpeed * this.traits.speed * thrust;

      // Move
      this.x += Math.cos(this.heading) * speed * dt;
      this.y += Math.sin(this.heading) * speed * dt;

      // Bounce from borders (no wrapping)
      let bounced = false;

      if (this.x < 0) {
        this.x = 0;
        this.heading = Math.PI - this.heading;
        bounced = true;
      } else if (this.x > CONFIG.worldWidth) {
        this.x = CONFIG.worldWidth;
        this.heading = Math.PI - this.heading;
        bounced = true;
      }

      if (this.y < 0) {
        this.y = 0;
        this.heading = -this.heading;
        bounced = true;
      } else if (this.y > CONFIG.worldHeight) {
        this.y = CONFIG.worldHeight;
        this.heading = -this.heading;
        bounced = true;
      }

      if (bounced) {
        while (this.heading > Math.PI) this.heading -= Math.PI * 2;
        while (this.heading < -Math.PI) this.heading += Math.PI * 2;
      }

      this.energy -= CONFIG.energyLossPerSecond * dt;
      this.energy -= CONFIG.moveEnergyFactor * speed * dt;

      const eatRadiusSq = (this.radius + CONFIG.foodRadius) ** 2;

      for (let i = foods.length - 1; i >= 0; i--) {
        const f = foods[i];
        if (distanceSq(this, f) <= eatRadiusSq) {
          foods.splice(i, 1);
          this.energy += CONFIG.foodEnergy;
          stats.foodEaten++;
          break;
        }
      }

      if (this.energy >= CONFIG.reproductionEnergy &&
          blobs.length < CONFIG.maxBlobs) {
        const childTraits = Blob.mutateTraits(this.traits);
        const childBrain = Brain.cloneAndMutate(this.brain, CONFIG.weightMutation);
        const child = new Blob(
          this.x,
          this.y,
          childTraits,
          childBrain,
          this.generation + 1,
          this,
          this.lineageRootId,
          this.lineagePath
        );

        child.energy = this.energy * 0.5;
        this.energy *= 0.5;

        blobs.push(child);
        stats.births++;
        if (child.generation > stats.maxGeneration) {
          stats.maxGeneration = child.generation;
        }
      }

      if (this.energy <= CONFIG.minEnergyToLive) {
        this.dead = true;
        stats.deaths++;
      }

      if (!this.dead) {
        this.attemptPredation(blobs, stats);
      }
    }

    draw(ctx) {
      const color = this.getColor();
      const r = this.radius;

      ctx.save();
      ctx.translate(this.x, this.y);

      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      const gradient = ctx.createRadialGradient(-r * 0.3, -r * 0.3, r * 0.2, 0, 0, r);
      gradient.addColorStop(0, "#ffffff");
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, "#050509");
      ctx.fillStyle = gradient;
      ctx.fill();

      const energyFactor = clamp(this.energy / CONFIG.reproductionEnergy, 0, 1);
      ctx.lineWidth = 1.2 + energyFactor * 1.8;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.4)";
      ctx.stroke();

      ctx.rotate(this.heading);
      ctx.beginPath();
      ctx.arc(r * 0.6, 0, r * 0.25, 0, Math.PI * 2);
      ctx.fillStyle = "#fdfdfd";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(r * 0.65, 0, r * 0.14, 0, Math.PI * 2);
      ctx.fillStyle = "rgba(10, 12, 24, 0.9)";
      ctx.fill();

      ctx.restore();
    }
  }

  // --- SIMULATION STATE ----------------------------------------------------

  const canvas = document.getElementById("sim");
  const ctx = canvas.getContext("2d");

  canvas.width = CONFIG.worldWidth;
  canvas.height = CONFIG.worldHeight;

  const nnCanvas = document.getElementById("nnCanvas");
  const nnCtx = nnCanvas.getContext("2d");
  nnCanvas.width = 480;
  nnCanvas.height = 260;

  let blobs = [];
  let foods = [];
  let running = true;
  let simSpeed = 1.0;
  let lastTime = null;

  let foodSpawnRate = CONFIG.defaultFoodSpawnRate; // foods per second
  let foodSpawnAccumulator = 0;                    // fractional foods to spawn

  const stats = {
    births: 0,
    deaths: 0,
    foodEaten: 0,
    ticks: 0,
    maxGeneration: 1,
    predations: 0
  };

  function spawnFood(n) {
    for (let i = 0; i < n; i++) {
      foods.push({
        x: Math.random() * CONFIG.worldWidth,
        y: Math.random() * CONFIG.worldHeight
      });
    }
  }

  function initSimulation() {
    blobs = [];
    foods = [];
    NEXT_BLOB_ID = 1;

    stats.births = 0;
    stats.deaths = 0;
    stats.foodEaten = 0;
    stats.ticks = 0;
    stats.maxGeneration = 1;
    stats.predations = 0;

    // Reset spawn rate state
    foodSpawnRate = parseFloat(document.getElementById("foodRateSlider").value) || CONFIG.defaultFoodSpawnRate;
    foodSpawnAccumulator = 0;

    // Initial food count is exactly this:
    spawnFood(CONFIG.foodCount);

    for (let i = 0; i < CONFIG.initialBlobs; i++) {
      const traits = Blob.randomTraits();
      const brain = new Brain(
        CONFIG.nnInputSize,
        CONFIG.nnHidden1Size,
        CONFIG.nnHidden2Size,
        CONFIG.nnOutputSize
      );
      const b = new Blob(
        Math.random() * CONFIG.worldWidth,
        Math.random() * CONFIG.worldHeight,
        traits,
        brain,
        1
      );
      blobs.push(b);
      stats.births++;
    }
  }

  // --- NN VISUALIZATION ----------------------------------------------------

  function getBestBlob() {
    if (blobs.length === 0) return null;
    let best = null;
    let bestGen = -Infinity;
    let bestEnergy = -Infinity;

    for (let i = 0; i < blobs.length; i++) {
      const b = blobs[i];
      if (b.generation > bestGen ||
          (b.generation === bestGen && b.energy > bestEnergy)) {
        best = b;
        bestGen = b.generation;
        bestEnergy = b.energy;
      }
    }
    return best;
  }

  function drawNeuralNetworkView(blob) {
    const w = nnCanvas.width;
    const h = nnCanvas.height;

    nnCtx.clearRect(0, 0, w, h);
    nnCtx.save();
    nnCtx.fillStyle = "rgba(5, 8, 20, 0.95)";
    nnCtx.fillRect(0, 0, w, h);

    nnCtx.font = "11px system-ui, sans-serif";
    nnCtx.textAlign = "left";
    nnCtx.textBaseline = "top";

    if (!blob || !blob.brain) {
      nnCtx.fillStyle = "rgba(230, 235, 255, 0.7)";
      nnCtx.textAlign = "center";
      nnCtx.fillText("No blobs alive – neural net view unavailable.", w / 2, h / 2 - 6);
      nnCtx.restore();
      return;
    }

    const brain = blob.brain;

    nnCtx.fillStyle = "rgba(230, 235, 255, 0.9)";
    nnCtx.fillText(
      `Gen ${blob.generation}, energy ${blob.energy.toFixed(1)}`,
      10,
      8
    );

    // layer x positions (4 layers)
    const xInput   = 70;
    const xHidden1 = w * 0.37;
    const xHidden2 = w * 0.63;
    const xOutput  = w - 70;

    const topMargin = 30;
    const bottomMargin = 20;

    const inputCount   = brain.inputSize;
    const hidden1Count = brain.hidden1Size;
    const hidden2Count = brain.hidden2Size;
    const outputCount  = brain.outputSize;

    function layerPositions(count, x) {
      const positions = [];
      if (count === 1) {
        positions.push({ x, y: (topMargin + h - bottomMargin) / 2 });
      } else {
        const span = (h - topMargin - bottomMargin);
        for (let i = 0; i < count; i++) {
          const t = count === 1 ? 0.5 : i / (count - 1);
          positions.push({ x, y: topMargin + t * span });
        }
      }
      return positions;
    }

    const inputNodes   = layerPositions(inputCount,   xInput);
    const hidden1Nodes = layerPositions(hidden1Count, xHidden1);
    const hidden2Nodes = layerPositions(hidden2Count, xHidden2);
    const outputNodes  = layerPositions(outputCount,  xOutput);

    // Collect all weights to normalize
    const weights = [];
    for (let h1 = 0; h1 < hidden1Count; h1++) {
      for (let i = 0; i < inputCount; i++) {
        weights.push(brain.weightsIH[h1][i]);
      }
    }
    for (let h2 = 0; h2 < hidden2Count; h2++) {
      for (let h1 = 0; h1 < hidden1Count; h1++) {
        weights.push(brain.weightsHH[h2][h1]);
      }
    }
    for (let o = 0; o < outputCount; o++) {
      for (let h2 = 0; h2 < hidden2Count; h2++) {
        weights.push(brain.weightsHO[o][h2]);
      }
    }

    let maxAbs = 0.001;
    for (let i = 0; i < weights.length; i++) {
      const a = Math.abs(weights[i]);
      if (a > maxAbs) maxAbs = a;
    }

    nnCtx.lineCap = "round";

    // Draw connections: input -> hidden1
    for (let h1 = 0; h1 < hidden1Count; h1++) {
      const hPos = hidden1Nodes[h1];
      for (let i = 0; i < inputCount; i++) {
        const iPos = inputNodes[i];
        const wVal = brain.weightsIH[h1][i];
        const norm = wVal / maxAbs;
        const strength = Math.abs(norm);

        const alpha = 0.12 + 0.7 * strength;
        const width = 0.4 + 2.2 * strength;

        let r, g, b;
        if (norm >= 0) {
          r = 255; g = 150 + Math.floor(80 * (1 - strength)); b = 80;
        } else {
          r = 80; g = 160 + Math.floor(60 * strength); b = 255;
        }

        nnCtx.strokeStyle = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
        nnCtx.lineWidth = width;
        nnCtx.beginPath();
        nnCtx.moveTo(iPos.x, iPos.y);
        nnCtx.lineTo(hPos.x, hPos.y);
        nnCtx.stroke();
      }
    }

    // Draw connections: hidden1 -> hidden2
    for (let h2 = 0; h2 < hidden2Count; h2++) {
      const h2Pos = hidden2Nodes[h2];
      for (let h1 = 0; h1 < hidden1Count; h1++) {
        const h1Pos = hidden1Nodes[h1];
        const wVal = brain.weightsHH[h2][h1];
        const norm = wVal / maxAbs;
        const strength = Math.abs(norm);

        const alpha = 0.12 + 0.7 * strength;
        const width = 0.4 + 2.2 * strength;

        let r, g, b;
        if (norm >= 0) {
          r = 255; g = 190; b = 100;
        } else {
          r = 100; g = 190; b = 255;
        }

        nnCtx.strokeStyle = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
        nnCtx.lineWidth = width;
        nnCtx.beginPath();
        nnCtx.moveTo(h1Pos.x, h1Pos.y);
        nnCtx.lineTo(h2Pos.x, h2Pos.y);
        nnCtx.stroke();
      }
    }

    // Draw connections: hidden2 -> output
    for (let o = 0; o < outputCount; o++) {
      const oPos = outputNodes[o];
      for (let h2 = 0; h2 < hidden2Count; h2++) {
        const h2Pos = hidden2Nodes[h2];
        const wVal = brain.weightsHO[o][h2];
        const norm = wVal / maxAbs;
        const strength = Math.abs(norm);

        const alpha = 0.12 + 0.7 * strength;
        const width = 0.4 + 2.2 * strength;

        let r, g, b;
        if (norm >= 0) {
          r = 255; g = 220; b = 120;
        } else {
          r = 120; g = 220; b = 255;
        }

        nnCtx.strokeStyle = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
        nnCtx.lineWidth = width;
        nnCtx.beginPath();
        nnCtx.moveTo(h2Pos.x, h2Pos.y);
        nnCtx.lineTo(oPos.x, oPos.y);
        nnCtx.stroke();
      }
    }

    // Draw nodes
    function drawNodes(nodes, radius, fill, stroke) {
      nnCtx.fillStyle = fill;
      nnCtx.strokeStyle = stroke;
      nnCtx.lineWidth = 1;
      for (let i = 0; i < nodes.length; i++) {
        const p = nodes[i];
        nnCtx.beginPath();
        nnCtx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        nnCtx.fill();
        nnCtx.stroke();
      }
    }

    drawNodes(inputNodes,   7,  "rgba(230, 235, 255, 0.95)", "rgba(10, 12, 24, 0.9)");
    drawNodes(hidden1Nodes, 6.5,"rgba(120, 180, 255, 0.9)",  "rgba(10, 12, 24, 0.9)");
    drawNodes(hidden2Nodes, 6.5,"rgba(160, 140, 255, 0.9)",  "rgba(10, 12, 24, 0.9)");
    drawNodes(outputNodes,  8,  "rgba(255, 140, 120, 0.95)", "rgba(10, 12, 24, 0.9)");

    // Input / output labels
    nnCtx.fillStyle = "rgba(220, 230, 255, 0.8)";
    nnCtx.textAlign = "center";
    nnCtx.textBaseline = "top";

    if (inputNodes.length === 12) {
      const labels = [
        "food L",
        "food L-mid",
        "food C",
        "food R-mid",
        "food R",
        "blob L",
        "blob L-mid",
        "blob C",
        "blob R-mid",
        "blob R",
        "energy",
        "bias"
      ];
      for (let i = 0; i < labels.length; i++) {
        nnCtx.fillText(labels[i], inputNodes[i].x, inputNodes[i].y + 10);
      }
    }

    nnCtx.textBaseline = "bottom";
    if (outputNodes.length === 2) {
      const labels = ["turn", "thrust"];
      for (let o = 0; o < 2; o++) {
        nnCtx.fillText(labels[o], outputNodes[o].x, outputNodes[o].y - 10);
      }
    }

    nnCtx.restore();
  }

  // --- RENDERING & UPDATE LOOP --------------------------------------------

  function update(dt) {
    stats.ticks++;

    if (foodSpawnRate > 0 && foods.length < CONFIG.foodCount) {
      foodSpawnAccumulator += dt * foodSpawnRate;
      const toSpawn = Math.floor(foodSpawnAccumulator);
      if (toSpawn > 0) {
        const allowed = CONFIG.foodCount - foods.length;
        if (allowed > 0) {
          spawnFood(Math.min(toSpawn, allowed));
        }
        foodSpawnAccumulator -= toSpawn;
      }
    }

    for (let i = 0; i < blobs.length; i++) {
      blobs[i].update(dt, foods, blobs, stats);
    }

    blobs = blobs.filter(b => !b.dead);
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.fillStyle = "rgba(5, 10, 20, 0.9)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = "rgba(255, 255, 255, 0.03)";
    ctx.lineWidth = 1;

    const gridSize = 40;
    ctx.beginPath();
    for (let x = 0; x <= canvas.width; x += gridSize) {
      ctx.moveTo(x + 0.5, 0);
      ctx.lineTo(x + 0.5, canvas.height);
    }
    for (let y = 0; y <= canvas.height; y += gridSize) {
      ctx.moveTo(0, y + 0.5);
      ctx.lineTo(canvas.width, y + 0.5);
    }
    ctx.stroke();
    ctx.restore();

    ctx.save();
    for (let i = 0; i < foods.length; i++) {
      const f = foods[i];
      const r = CONFIG.foodRadius;
      const gradient = ctx.createRadialGradient(f.x - 1, f.y - 1, 0, f.x, f.y, r * 2.2);
      gradient.addColorStop(0, "#e5ffe0");
      gradient.addColorStop(0.4, "#66ff88");
      gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(f.x, f.y, r * 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    for (let i = 0; i < blobs.length; i++) {
      blobs[i].draw(ctx);
    }

    ctx.save();
    ctx.font = "10px system-ui, sans-serif";
    ctx.fillStyle = "rgba(230, 235, 255, 0.75)";
    ctx.textAlign = "left";
    ctx.textBaseline = "bottom";
    const text = `Blobs: ${blobs.length}/${CONFIG.maxBlobs}   Food: ${foods.length}/${CONFIG.foodCount}`;
    ctx.fillText(text, 10, canvas.height - 8);
    ctx.restore();

    const bestBlob = getBestBlob();
    drawNeuralNetworkView(bestBlob);
  }

  function loop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dtMs = timestamp - lastTime;
    lastTime = timestamp;
    const dt = (dtMs / 1000) * simSpeed;

    if (running) {
      update(dt);
      draw();
      updateStatsPanel();
    } else {
      draw();
    }

    window.requestAnimationFrame(loop);
  }

  // --- UI ------------------------------------------------------------------

  const toggleBtn = document.getElementById("toggleBtn");
  const resetBtn = document.getElementById("resetBtn");
  const speedSlider = document.getElementById("speedSlider");
  const speedValue = document.getElementById("speedValue");
  const foodRateSlider = document.getElementById("foodRateSlider");
  const foodRateValue = document.getElementById("foodRateValue");
  const statsDiv = document.getElementById("stats");

  function updateStatsPanel() {
    const avgGeneration =
      blobs.length > 0
        ? (blobs.reduce((acc, b) => acc + b.generation, 0) / blobs.length).toFixed(2)
        : "–";

    const avgSpeed =
      blobs.length > 0
        ? (blobs.reduce((acc, b) => acc + b.traits.speed, 0) / blobs.length).toFixed(2)
        : "–";

    const avgSensor =
      blobs.length > 0
        ? (blobs.reduce((acc, b) => acc + b.traits.sensorRange, 0) / blobs.length).toFixed(1)
        : "–";

    const avgSize =
      blobs.length > 0
        ? (blobs.reduce((acc, b) => acc + b.traits.size, 0) / blobs.length).toFixed(2)
        : "–";

    statsDiv.innerHTML = `
      <div><strong>Population:</strong> ${blobs.length} / ${CONFIG.maxBlobs}</div>
      <div><strong>Births:</strong> ${stats.births} &nbsp; <strong>Deaths:</strong> ${stats.deaths}</div>
      <div><strong>Max generation seen:</strong> ${stats.maxGeneration}</div>
      <div style="margin-top:6px;"><strong>Average traits (current blobs)</strong></div>
      <div>Speed: <code>${avgSpeed}</code></div>
      <div>Sensor range: <code>${avgSensor}</code></div>
      <div>Size: <code>${avgSize}</code></div>
      <div style="margin-top:6px;"><strong>Food eaten:</strong> ${stats.foodEaten}</div>
      <div><strong>Predation events:</strong> ${stats.predations}</div>
      <div style="margin-top:6px;"><strong>Food spawn rate:</strong> ${foodSpawnRate.toFixed(1)} / s</div>
      <div><strong>FOV:</strong> ${CONFIG.fovDegrees}&deg;</div>
    `;
  }

  toggleBtn.addEventListener("click", () => {
    running = !running;
    toggleBtn.textContent = running ? "Pause" : "Resume";
    if (running) {
      updateStatsPanel();
    }
  });

  resetBtn.addEventListener("click", () => {
    initSimulation();
    updateStatsPanel();
  });

  speedSlider.addEventListener("input", () => {
    simSpeed = parseFloat(speedSlider.value);
    speedValue.textContent = simSpeed.toFixed(1) + "x";
  });

  foodRateSlider.addEventListener("input", () => {
    foodSpawnRate = parseFloat(foodRateSlider.value);
    foodRateValue.textContent = foodSpawnRate.toFixed(1) + "/s";
  });

  // --- START --------------------------------------------------------------
  foodSpawnRate = CONFIG.defaultFoodSpawnRate;
  foodRateSlider.value = CONFIG.defaultFoodSpawnRate;
  foodRateValue.textContent = CONFIG.defaultFoodSpawnRate.toFixed(1) + "/s";

  initSimulation();
  updateStatsPanel();
  window.requestAnimationFrame(loop);
</script>
</body>
</html>

